// Copyright (c) 2018-2022 The MobileCoin Foundation

//! Configuration for the avr verifier.

use crate::{
    error::ParseError,
    get_signing_key_from_verification_report_data,
    metadata_verifiers::avr::{AvrVerificationRecord, AvrVerifier},
    VerificationError,
};
use mc_attest_core::serial;
use mc_attest_verifier::Verifier;
use mc_blockchain_types::{BlockIndex, VerificationReport};
use mc_common::ResponderId;
use mc_crypto_keys::Ed25519Public;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, ffi::OsStr, fs, path::Path};

/// Struct for holding reading historical Intel Attestation Verification
/// data from a configuration file.
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct AvrHistoryConfig {
    /// AVR Records
    #[serde(rename = "node")]
    avr_records: Vec<AvrHistoryRecord>,
}

impl AvrHistoryConfig {
    /// Create new AVR config from a list of AVR records
    pub fn new(avr_records: Vec<AvrHistoryRecord>) -> Self {
        let mut records = Self { avr_records };
        records.avr_records.sort();
        records
    }

    /// Load the [AvrHistoryConfig] from a .json or .toml file
    pub fn load(path: impl AsRef<Path>) -> Result<Self, ParseError> {
        let path = path.as_ref();
        let bytes = fs::read(path)?;
        let mut config: AvrHistoryConfig = match path.extension().and_then(OsStr::to_str) {
            Some("toml") => Ok(toml::from_slice(&bytes)?),
            Some("json") => Ok(serde_json::from_slice(&bytes)?),
            _ => Err(ParseError::UnrecognizedExtension(path.into())),
        }?;
        config.avr_records.sort();
        Ok(config)
    }

    /// Verify historical records:
    /// 1. Don't have duplicate block signing keys
    /// 2. Have no overlapping/invalid ranges
    /// 3. Each have a [VerificationReport] that was generated by an
    /// enclave signed by Intel
    ///
    /// Returns an [AvrVerifier] if all verifications pass
    pub fn verify_data(&self, avr_verifier: &Verifier) -> Result<AvrVerifier, VerificationError> {
        let mut avr_history: HashMap<Ed25519Public, AvrVerificationRecord> = HashMap::new();
        for (i, record) in self.avr_records.iter().enumerate() {
            // Ensure the last index >= start index
            if record.first_block_index > record.last_block_index {
                return Err(VerificationError::InvalidRange(
                    record.first_block_index,
                    record.last_block_index,
                    record.responder_id.clone(),
                ));
            }
            // Ensure ranges don't overlap
            if i > 0
                && self.avr_records[i - 1].responder_id == record.responder_id
                && self.avr_records[i - 1].last_block_index >= record.first_block_index
            {
                return Err(VerificationError::ResponderRangeOverlap(
                    record.first_block_index,
                    record.last_block_index,
                    self.avr_records[i - 1].first_block_index,
                    self.avr_records[i - 1].last_block_index,
                    record.responder_id.clone(),
                ));
            }
            // Ensure all AVRs were generated by an Intel Signed enclave
            // and that no duplicate block signing keys exist
            if let Some(avr) = record.avr.as_ref() {
                let verification_data = avr_verifier.verify(avr)?;
                let signing_key =
                    get_signing_key_from_verification_report_data(&verification_data)?;
                if let Some(rec) = avr_history.get(&signing_key) {
                    return Err(VerificationError::DuplicateBlockSigningKey(
                        hex::encode(signing_key),
                        record.first_block_index,
                        record.last_block_index,
                        *rec.block_range.start(),
                        *rec.block_range.end(),
                    ));
                }
                let verification_record = AvrVerificationRecord {
                    block_range: record.first_block_index..=record.last_block_index,
                    responder_id: record.responder_id.clone(),
                    avr: avr.clone(),
                };
                avr_history.insert(signing_key, verification_record);
            }
        }
        Ok(AvrVerifier {
            avr_history,
            avr_verifier: avr_verifier.clone(),
        })
    }
}

/// Stores a historical AVR record (or lack thereof) for a given
/// ResponderId and block range
#[derive(Clone, Debug, Deserialize, Eq, Ord, PartialEq, PartialOrd, Serialize)]
pub struct AvrHistoryRecord {
    /// Uri of the consensus node
    pub responder_id: ResponderId,

    /// Block the AVR Report for the signing key becomes valid
    pub first_block_index: BlockIndex,

    /// Final block the AVR Report for the signing key is valid
    pub last_block_index: BlockIndex,

    /// AVR Report (or lack thereof) for the node & block ranges
    #[serde(default, with = "serial")]
    pub avr: Option<VerificationReport>,
}

impl AvrHistoryRecord {
    /// Create new AVRConfigRecord
    pub fn new(
        responder_id: &ResponderId,
        first_block_index: BlockIndex,
        last_block_index: BlockIndex,
        avr: Option<VerificationReport>,
    ) -> Self {
        Self {
            responder_id: responder_id.clone(),
            first_block_index,
            last_block_index,
            avr,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_utils::{
        get_avr_history_config, get_ias_reports, get_ias_verifier, SAMPLE_AVR_HISTORY_JSON,
        SAMPLE_AVR_HISTORY_TOML,
    };
    use std::str::FromStr;
    use tempfile::TempDir;

    // Our test data uses data from real IAS history, these data represent
    // block ranges for certain AVRs were valid for consensus node
    // node1.prod.mobilecoinww.com including a period where AVRs were not
    // tracked
    const EMPTY_AVR_START: BlockIndex = 0;
    const EMPTY_AVR_END: BlockIndex = 480;
    const AVR_1_START: BlockIndex = 481;
    const AVR_1_END: BlockIndex = 10399;
    const AVR_2_START: BlockIndex = 10400;
    const AVR_2_END: BlockIndex = 11021;

    #[test]
    fn test_avr_history_serialization_roundtrip_works() {
        // Get a manually constructed AVR history config to act as control
        let control_avr_history = get_avr_history_config();

        // Serialize the config to JSON & TOML
        let toml_str = toml::to_string_pretty(&control_avr_history).unwrap();
        let json_str = serde_json::to_string_pretty(&control_avr_history).unwrap();
        let history_from_toml: AvrHistoryConfig = toml::from_str(toml_str.as_str()).unwrap();
        let history_from_json: AvrHistoryConfig = serde_json::from_str(json_str.as_str()).unwrap();

        // Assert that deserialization from JSON and TOML is the same as the original
        // config
        assert_eq!(control_avr_history, history_from_toml);
        assert_eq!(control_avr_history, history_from_json);
    }

    #[test]
    fn test_avr_history_load_from_disk() {
        // Get a manually constructed AVR history config to act as control
        let control_avr_history = get_avr_history_config();

        // Write JSON and TOML to disk
        let temp = TempDir::new().unwrap();
        let path_json = temp.path().join("avr-history.json");
        let path_toml = temp.path().join("avr-history.toml");
        fs::write(&path_json, SAMPLE_AVR_HISTORY_JSON).unwrap();
        fs::write(&path_toml, SAMPLE_AVR_HISTORY_TOML).unwrap();

        // Load the config from disk
        let avr_history_from_json = AvrHistoryConfig::load(path_json).unwrap();
        let avr_history_from_toml = AvrHistoryConfig::load(path_toml).unwrap();

        // Check that the avr histories loaded from disk are the same as the control
        assert_eq!(control_avr_history, avr_history_from_json);
        assert_eq!(control_avr_history, avr_history_from_toml);
    }

    #[test]
    fn test_avr_history_verification_works_for_valid_records() {
        // Get a manually constructed AVR history config to act as control
        // and generate an AvrVerifier from it
        let control_avr_history = get_avr_history_config();
        let ias_verifier = get_ias_verifier();
        let avr_verifier = control_avr_history.verify_data(&ias_verifier).unwrap();

        // Get historical signing keys from the control data
        let (avr1, avr2) = get_ias_reports();
        let ias_verifier = get_ias_verifier();
        let verification_data1 = ias_verifier.verify(&avr1).unwrap();
        let verification_data2 = ias_verifier.verify(&avr2).unwrap();
        let signing_key_1 =
            get_signing_key_from_verification_report_data(&verification_data1).unwrap();
        let signing_key_2 =
            get_signing_key_from_verification_report_data(&verification_data2).unwrap();

        // Check the verification records used to verify blocks match the control data
        let avr_verification_record_1 = avr_verifier.avr_history.get(&signing_key_1).unwrap();
        let avr_verification_record_2 = avr_verifier.avr_history.get(&signing_key_2).unwrap();
        assert_eq!(avr_verifier.avr_history.len(), 2);
        assert_eq!(AVR_1_START, *avr_verification_record_1.block_range.start());
        assert_eq!(AVR_1_END, *avr_verification_record_1.block_range.end());
        assert_eq!(AVR_2_START, *avr_verification_record_2.block_range.start());
        assert_eq!(AVR_2_END, *avr_verification_record_2.block_range.end());
        assert_eq!(
            avr_verification_record_1.responder_id.0.as_str(),
            "node1.prod.mobilecoinww.com::8443"
        );
        assert_eq!(
            avr_verification_record_2.responder_id.0.as_str(),
            "node1.prod.mobilecoinww.com::8443"
        );
    }

    #[test]
    fn test_avr_history_fails_for_invalid_ranges() {
        let (avr1, avr2) = get_ias_reports();
        let responder_id = ResponderId::from_str("node1.prod.mobilecoinww.com::8443").unwrap();

        // Create historical config with overlapping ranges
        let rec1 = AvrHistoryRecord::new(&responder_id, EMPTY_AVR_START, EMPTY_AVR_END, None);
        let rec2 =
            AvrHistoryRecord::new(&responder_id, EMPTY_AVR_END, AVR_1_END, Some(avr1.clone()));
        let rec3 = AvrHistoryRecord::new(&responder_id, AVR_2_START, AVR_2_END, Some(avr2));
        let overlapping_range_history = AvrHistoryConfig::new(vec![rec1, rec2, rec3]);

        // Create historical config with invalid ranges
        let rec4 = AvrHistoryRecord::new(&responder_id, 0, 480, None);
        let rec5 = AvrHistoryRecord::new(&responder_id, 10399, 480, Some(avr1));
        let invalid_range_history = AvrHistoryConfig::new(vec![rec4, rec5]);

        // Check that the errors covering both cases are triggered
        assert!(matches!(
            overlapping_range_history.verify_data(&get_ias_verifier()),
            Err(VerificationError::ResponderRangeOverlap(_, _, _, _, _))
        ));
        assert!(matches!(
            invalid_range_history.verify_data(&get_ias_verifier()),
            Err(VerificationError::InvalidRange(_, _, _))
        ));
    }

    #[test]
    fn test_avr_history_verification_fails_for_duplicate_block_signing_keys() {
        let (avr1, _) = get_ias_reports();

        // Create config with duplicate block signing keys
        let responder_id = ResponderId::from_str("node1.prod.mobilecoinww.com::8443").unwrap();
        let rec1 = AvrHistoryRecord::new(&responder_id, EMPTY_AVR_START, EMPTY_AVR_END, None);
        let rec2 = AvrHistoryRecord::new(&responder_id, AVR_1_START, AVR_1_END, Some(avr1.clone()));
        let rec3 = AvrHistoryRecord::new(&responder_id, AVR_2_START, AVR_2_END, Some(avr1));
        let duplicate_config = AvrHistoryConfig::new(vec![rec1, rec2, rec3]);

        // Check that the appropriate error is triggered
        assert!(matches!(
            duplicate_config.verify_data(&get_ias_verifier()),
            Err(VerificationError::DuplicateBlockSigningKey(_, _, _, _, _))
        ));
    }

    #[test]
    fn test_avr_history_fails_for_invalid_avrs() {
        let avr = VerificationReport::default();

        // Create config with faulty avr
        let responder_id = ResponderId::from_str("node1.prod.mobilecoinww.com::8443").unwrap();
        let rec1 = AvrHistoryRecord::new(&responder_id, EMPTY_AVR_START, EMPTY_AVR_END, None);
        let rec2 = AvrHistoryRecord::new(&responder_id, AVR_1_START, AVR_1_END, None);
        let rec3 = AvrHistoryRecord::new(&responder_id, AVR_2_START, AVR_2_END, Some(avr));
        let duplicate_config = AvrHistoryConfig::new(vec![rec1, rec2, rec3]);

        // Check that the appropriate error is triggered
        assert!(matches!(
            duplicate_config.verify_data(&get_ias_verifier()),
            Err(VerificationError::InvalidAvr(_))
        ));
    }
}
