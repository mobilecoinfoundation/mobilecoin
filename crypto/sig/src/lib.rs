#![no_std]

//! Simplified API for using Schnorrkel in a deterministic manner, with simple
//! ristretto key pairs, where the public key is a RistretoPoint and the private key is a Scalar.
//!
//! mc-crypto-keys crate provides wrappers RistrettoPublic and RistrettoPrivate around these
//! and implements many handy traits for performing high-level cryptography operations,
//! and this crate provides a way to create signatures that is compatible with these key pairs.

use mc_crypto_keys::{RistrettoPrivate, RistrettoPublic};
pub use schnorrkel::{Signature, SignatureError, SIGNATURE_LENGTH};

/// Create a deterministic Schnorrkel signature
///
/// Arguments:
/// * context_tag: Domain separation tag for the signatures
/// * private_key: The RistrettoPrivate key used to sign the message
/// * message: The message that is signed
///
/// Returns:
/// * A 64-byte Schnorrkel Signature object which can be converted to and from bytes using its API.
pub fn sign(
    context_tag: &'static [u8],
    private_key: &RistrettoPrivate,
    message: &[u8],
) -> Signature {
    private_key.sign_schnorrkel(context_tag, message)
}

/// Verify a Schnorrkel signature
///
/// Note that this should work correctly even with Schnorrkel signatures not generated by the sign function
/// above, because the details of the nonce generation don't affect whether the signature passes verification.
/// The signing context bytes will matter though, if the other party is using a special signing context then
/// we must provide the same signing context bytes.
///
/// Arguments:
/// * context_tag: Domain separation tag for the signatures.
/// * public_key: Public key to check the signature against.
/// * message: The message that is signed.
/// * signature: The signature object to verify.
///
/// Returns:
/// * Ok if the signature checks out, SignatureError otherwise.
pub fn verify(
    context_tag: &'static [u8],
    public_key: &RistrettoPublic,
    message: &[u8],
    signature: &Signature,
) -> Result<(), SignatureError> {
    public_key.verify_schnorrkel(context_tag, message, signature)
}

#[cfg(test)]
mod tests {
    use super::*;
    use mc_util_from_random::FromRandom;
    use mc_util_test_helper::run_with_several_seeds;

    // Expected successes
    #[test]
    fn expected_success() {
        run_with_several_seeds(|mut rng| {
            let seckey = RistrettoPrivate::from_random(&mut rng);
            let pubkey = RistrettoPublic::from(&seckey);

            let sig = sign(b"test", &seckey, b"foobar");
            verify(b"test", &pubkey, b"foobar", &sig).expect("unexpected failure");
        })
    }
    // Expected failure when key is different
    #[test]
    fn expected_failure_bad_keys() {
        run_with_several_seeds(|mut rng| {
            let seckey = RistrettoPrivate::from_random(&mut rng);
            let seckey2 = RistrettoPrivate::from_random(&mut rng);
            let pubkey = RistrettoPublic::from(&seckey);

            let sig = sign(b"test", &seckey2, b"foobar");
            let result = verify(b"test", &pubkey, b"foobar", &sig);
            assert!(!result.is_ok());
        })
    }
    // Expected failure when message is different
    #[test]
    fn expected_failure_bad_message() {
        run_with_several_seeds(|mut rng| {
            let seckey = RistrettoPrivate::from_random(&mut rng);
            let pubkey = RistrettoPublic::from(&seckey);

            let sig = sign(b"test", &seckey, b"foobar");
            let result = verify(b"test", &pubkey, b"foobarbaz", &sig);
            assert!(!result.is_ok());
        })
    }

    // Expected failure when context is different
    #[test]
    fn expected_failure_bad_context() {
        run_with_several_seeds(|mut rng| {
            let seckey = RistrettoPrivate::from_random(&mut rng);
            let pubkey = RistrettoPublic::from(&seckey);

            let sig = sign(b"test", &seckey, b"foobar");
            let result = verify(b"prod", &pubkey, b"foobar", &sig);
            assert!(!result.is_ok());
        })
    }
}
