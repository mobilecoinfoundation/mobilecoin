// Copyright (c) 2018-2021 The MobileCoin Foundation

use core::option::Option;
use rand::rngs::adapter::ReseedingRng;
use rand_core::{impls, CryptoRng, Error, RngCore, SeedableRng};

// Using Hc128Rng because it was (at one point) the StdRng of rand crate, up to
// version 0.6 We don't want to depend on rand because it depends on std, and
// specifically, its implementation of ThreadRng depends on rust stdlib
// thread_local! macro
use rand_hc::Hc128Core as Core;

// Number of generated bytes after which to reseed `ThreadRng`.
// This constant is taken from rand and is not public.
const THREAD_RNG_RESEED_THRESHOLD: u64 = 1024 * 64;

type InnerRng = ReseedingRng<Core, OsRng>;

// Compare this impl with rand::thread_rng
#[thread_local]
static mut THREAD_LOCAL_RNG: Option<InnerRng> = None;

// Get the thread local instance, initializing it if that hasn't happened yet in
// this thread
fn get_thread_local_rng() -> &'static mut InnerRng {
    // unsafe is required because we are accessing a static mut,
    // but it is thread_local so this is not actually a problem.
    unsafe {
        THREAD_LOCAL_RNG.get_or_insert_with(|| {
            let r = Core::from_rng(OsRng)
                .unwrap_or_else(|err| panic!("could not initialize thread_rng: {}", err));
            ReseedingRng::new(r, THREAD_RNG_RESEED_THRESHOLD, OsRng)
        })
    }
}

// The ZWT we give to users
// Similar to rand::ThreadRng
#[derive(Default)]
pub struct McRng;

// Forward implementation from InnerRng
impl RngCore for McRng {
    #[inline]
    fn next_u32(&mut self) -> u32 {
        get_thread_local_rng().next_u32()
    }
    fn next_u64(&mut self) -> u64 {
        get_thread_local_rng().next_u64()
    }
    fn fill_bytes(&mut self, dest: &mut [u8]) {
        get_thread_local_rng().fill_bytes(dest)
    }
    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
        get_thread_local_rng().try_fill_bytes(dest)
    }
}

impl CryptoRng for McRng {}

/// OsRng
///
/// We have to copy OsRng from rand_core unfortunately, because cargo:
/// To get rand_core::OsRng, we must turn on `rand_core/getrandom` cargo
/// feature, but this appears to turns on `libc/std`.
/// There is therefore no way to get rand_core::OsRng without turning on the
/// standard library. Fortunately this body of code is trivial
///
/// This may just be a versioning issue? it may be that if rand_core upgrades
/// the version of getrandom that they rely on, we will be able to use
/// rand_core/getrandom without getting std, and then wouldn't have to carry
/// this.
#[derive(Clone, Copy, Debug, Default)]
struct OsRng;

impl CryptoRng for OsRng {}

impl RngCore for OsRng {
    fn next_u32(&mut self) -> u32 {
        impls::next_u32_via_fill(self)
    }

    fn next_u64(&mut self) -> u64 {
        impls::next_u64_via_fill(self)
    }

    fn fill_bytes(&mut self, dest: &mut [u8]) {
        if let Err(e) = self.try_fill_bytes(dest) {
            panic!("Error: {}", e);
        }
    }

    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
        getrandom::getrandom(dest).map_err(|e| e.code())?;
        Ok(())
    }
}
