// Copyright (c) 2018-2021 The MobileCoin Foundation

//! Errors generated by the mobilecoind system

use crate::db_crypto::DbCryptoError;
use displaydoc::Display;
use lmdb::Error as LmdbError;
use mc_connection::Error as ConnectionError;
use mc_consensus_api::ConversionError;
use mc_crypto_keys::KeyError;
use mc_ledger_db::Error as LedgerDbError;
use mc_util_lmdb::MetadataStoreError;
use mc_util_serial::{decode::Error as DecodeError, encode::Error as EncodeError};
use prost::DecodeError as ProstDecodeError;
use retry::Error as RetryError;

#[derive(Debug, Display)]
pub enum Error {
    /// Failure with LMDB: {0}
    Lmdb(LmdbError),

    /// Failure with LedgerDB: {0}
    LedgerDB(LedgerDbError),

    /// Failure with serialization: {0}
    Serialization(EncodeError),

    /// Failure with deserialization: {0}
    Deserialization(DecodeError),

    /// Prost (proto) decode error: {0}
    ProstDecode(ProstDecodeError),

    /// Connection error: {0:?}
    Connection(RetryError<ConnectionError>),

    /// IO error: {0}
    IO(std::io::Error),

    /// API conversion error: {0}
    ApiConversion(mc_consensus_api::ConversionError),

    /// Key error: {0}
    Key(KeyError),

    /// Channel send error
    ChannelSend,

    /// Invalid argument: {0}: {1}
    InvalidArgument(String, String),

    /// An entry in MonitorStore already exists for this MonitorId key
    MonitorIdExists,

    /// No matching key in MonitorStore was found
    MonitorIdNotFound,

    /// Failed to deserialize lmdb key bytes
    KeyDeserializationError,

    /// Subaddress SPK not found
    SubaddressSPKNotFound,

    /// An entry in SubaddressStore already exists for this index
    SubaddressSPKIdExists,

    /// Got transactions data but no key images - this should never happen
    MissingKeyImagesInLedgerDb,

    /// UnspentTxOut already in database
    DuplicateUnspentTxOut,

    /// No matching key was found in UtxoStore:subaddress_id_to_utxo_id
    SubaddressIdNotFound,

    /// No matching key was found in UtxoStore:utxo_id_to_utxo
    UtxoIdNotFound,

    /// Optimization not beneficial: {0}
    OptimizationNotBeneficial(String),

    /// Tx build error: {0}
    TxBuildError(String),

    /// Fog error: {0}
    FogError(String),

    /// Insufficient funds
    InsufficientFunds,

    /// Insufficient funds due to UTXO fragmentation
    InsufficientFundsFragmentedUtxos,

    /// The validator node we're tying to talk to was not found
    NodeNotFound,

    /// The ledger does not contain enough tx outs for rings
    InsufficientTxOuts,

    /// Block index {0} is lower than the monitor's first block {1}
    BlockIndexTooSmall(u64, u64),

    /// Block index {0} is equal or bigger than the monitor's next block {1}
    BlockNotYetProcessed(u64, u64),

    /// Metadata store error: {0}
    MetadataStore(MetadataStoreError),

    /// No peers configured - running in offline mode
    NoPeersConfigured,

    /// Db encryption: {0}
    DbCrypto(DbCryptoError),
}

impl From<RetryError<ConnectionError>> for Error {
    fn from(e: RetryError<ConnectionError>) -> Self {
        Self::Connection(e)
    }
}

impl From<LmdbError> for Error {
    fn from(e: LmdbError) -> Self {
        Self::Lmdb(e)
    }
}

impl From<LedgerDbError> for Error {
    fn from(e: LedgerDbError) -> Self {
        Self::LedgerDB(e)
    }
}

impl From<EncodeError> for Error {
    fn from(e: EncodeError) -> Self {
        Self::Serialization(e)
    }
}

impl From<DecodeError> for Error {
    fn from(e: DecodeError) -> Self {
        Self::Deserialization(e)
    }
}

impl From<ProstDecodeError> for Error {
    fn from(e: ProstDecodeError) -> Self {
        Self::ProstDecode(e)
    }
}

impl From<std::io::Error> for Error {
    fn from(e: std::io::Error) -> Self {
        Self::IO(e)
    }
}

impl<M> From<crossbeam_channel::SendError<M>> for Error {
    fn from(_e: crossbeam_channel::SendError<M>) -> Self {
        Self::ChannelSend
    }
}

impl From<ConversionError> for Error {
    fn from(e: ConversionError) -> Self {
        Self::ApiConversion(e)
    }
}

impl From<KeyError> for Error {
    fn from(e: KeyError) -> Self {
        Self::Key(e)
    }
}

impl From<MetadataStoreError> for Error {
    fn from(e: MetadataStoreError) -> Self {
        Self::MetadataStore(e)
    }
}

impl From<DbCryptoError> for Error {
    fn from(e: DbCryptoError) -> Self {
        Self::DbCrypto(e)
    }
}
