#![allow(clippy::result_large_err)]

mod autogenerated_code {
    // Expose proto data types from included third-party/external proto files.
    pub use mc_api::external;
    pub use mc_attest_api::attest;
    pub use mc_fog_report_api::fog_report;
    // Include the auto-generated code.

    pub mod account_ingest {
        include!(concat!(
            env!("OUT_DIR"),
            "/protos-auto-gen/account_ingest.rs"
        ));
    }
    pub mod fog_view {
        include!(concat!(env!("OUT_DIR"), "/protos-auto-gen/fog_view.rs"));
    }
    pub mod fog_ledger {
        include!(concat!(env!("OUT_DIR"), "/protos-auto-gen/fog_ledger.rs"));
    }
    pub mod ingest_common {
        include!(concat!(
            env!("OUT_DIR"),
            "/protos-auto-gen/ingest_common.rs"
        ));
    }
    pub mod kex_rng {
        include!(concat!(env!("OUT_DIR"), "/protos-auto-gen/kex_rng.rs"));
    }
    pub mod fog_common {
        include!(concat!(env!("OUT_DIR"), "/protos-auto-gen/fog_common.rs"));
    }
    pub mod ingest_peer {
        include!(concat!(env!("OUT_DIR"), "/protos-auto-gen/ingest_peer.rs"));
    }
}

pub use autogenerated_code::*;

pub mod report_parse;

pub mod conversions;

use grpcio::{CallOption, Metadata, Result as GrpcResult};
use mc_fog_uri::{IngestPeerUri, UriParseError};
use std::{collections::BTreeSet, str::FromStr};

// For tests, we need to implement Eq on view::QueryRequest
// They implement PartialEq but not Eq for some reason
impl Eq for autogenerated_code::fog_view::QueryRequest {}
impl Eq for autogenerated_code::fog_view::QueryRequestAad {}
impl Eq for autogenerated_code::kex_rng::KexRngPubkey {}
impl Eq for autogenerated_code::kex_rng::StoredRng {}

// Extra functions for IngestSummary to avoid repetition
impl ingest_common::IngestSummary {
    pub fn get_sorted_peers(&self) -> Result<BTreeSet<IngestPeerUri>, UriParseError> {
        self.peers
            .iter()
            .map(|x| IngestPeerUri::from_str(x))
            .collect()
    }
}

// Implement the EnclaveGrpcChannel trait on attested service types.
// If we don't do this in this crate, then newtype wrappers must be used,
// because of orphan rules
use mc_fog_enclave_connection::EnclaveGrpcChannel;

impl EnclaveGrpcChannel for fog_view::FogViewApiClient {
    fn auth(
        &mut self,
        msg: &attest::AuthMessage,
        call_option: CallOption,
    ) -> GrpcResult<(Metadata, attest::AuthMessage, Metadata)> {
        <Self>::auth_async_opt(self, msg, call_option)?.receive_sync()
    }
    fn enclave_request(
        &mut self,
        msg: &attest::Message,
        call_option: CallOption,
    ) -> GrpcResult<(Metadata, attest::Message, Metadata)> {
        <Self>::query_async_opt(self, msg, call_option)?.receive_sync()
    }
}

impl EnclaveGrpcChannel for fog_ledger::FogKeyImageApiClient {
    fn auth(
        &mut self,
        msg: &attest::AuthMessage,
        call_option: CallOption,
    ) -> GrpcResult<(Metadata, attest::AuthMessage, Metadata)> {
        <Self>::auth_async_opt(self, msg, call_option)?.receive_sync()
    }
    fn enclave_request(
        &mut self,
        msg: &attest::Message,
        call_option: CallOption,
    ) -> GrpcResult<(Metadata, attest::Message, Metadata)> {
        <Self>::check_key_images_async_opt(self, msg, call_option)?.receive_sync()
    }
}

impl EnclaveGrpcChannel for fog_ledger::FogMerkleProofApiClient {
    fn auth(
        &mut self,
        msg: &attest::AuthMessage,
        call_option: CallOption,
    ) -> GrpcResult<(Metadata, attest::AuthMessage, Metadata)> {
        <Self>::auth_async_opt(self, msg, call_option)?.receive_sync()
    }
    fn enclave_request(
        &mut self,
        msg: &attest::Message,
        call_option: CallOption,
    ) -> GrpcResult<(Metadata, attest::Message, Metadata)> {
        <Self>::get_outputs_async_opt(self, msg, call_option)?.receive_sync()
    }
}
