// Copyright (c) 2018-2021 The MobileCoin Foundation

//! APIs for report-caching enclaves.

#![no_std]

use core::result::Result as StdResult;
use displaydoc::Display;
use mc_attest_core::{
    IasNonce, Quote, QuoteNonce, Report, SgxError, TargetInfo, VerificationReport,
};
use mc_attest_enclave_api::Error as AttestEnclaveError;
use mc_util_serial::{decode::Error as RmpDecodeError, encode::Error as RmpEncodeError};
use serde::{Deserialize, Serialize};

/// An enumeration of errors which can be returned by the methods of the
/// `ReportableEnclave` trait.
#[derive(Debug, Display, Deserialize, Serialize)]
pub enum Error {
    /// Attest enclave error: {0}
    AttestEnclave(AttestEnclaveError),

    /// Error while serializing/deserializing
    Serialization,

    /// Error communicating with SGX: {0}
    Sgx(SgxError),
}

impl From<AttestEnclaveError> for Error {
    fn from(src: AttestEnclaveError) -> Self {
        Self::AttestEnclave(src)
    }
}

impl From<RmpEncodeError> for Error {
    fn from(_src: RmpEncodeError) -> Error {
        Error::Serialization
    }
}

impl From<RmpDecodeError> for Error {
    fn from(_src: RmpDecodeError) -> Error {
        Error::Serialization
    }
}

impl From<SgxError> for Error {
    fn from(src: SgxError) -> Self {
        Self::Sgx(src)
    }
}

/// A type alias for a ReportableEnclave result.
pub type Result<T> = StdResult<T, Error>;

/// A trait that report-caching enclaves need to implement in order to benefit
/// from the functionality provided in `mc-sgx-report-cache-untrusted`.
pub trait ReportableEnclave {
    /// Retrieve a new report for this enclave, targetted for the given
    /// quoting enclave. Untrusted code should call this on startup as
    /// part of the initialization process.
    fn new_ereport(&self, qe_info: TargetInfo) -> Result<(Report, QuoteNonce)>;

    /// Checks the quote and it's generating enclave for validity.
    ///
    /// Untrusted code should create a quote using the output of
    /// `new_ereport()`, then pass the resulting quote here in order to
    /// sanity-check the quoting enclave, advance the cache state machine.
    ///
    /// The implementing enclave will verify the quoted report matches
    /// the one generated by the last call to `new_ereport()`, and cache
    /// the results, which will be used to verify
    fn verify_quote(&self, quote: Quote, qe_report: Report) -> Result<IasNonce>;

    /// Cache the verification report for this enclave.
    ///
    /// Untrusted code should transmit the quote previously checked by
    /// `check_quote()` to IAS, and construct the verification report structure
    /// from the results. That result should be given back to the enclave
    /// for future use.
    ///
    /// The enclave will verify the IAS report was signed by a trusted IAS
    /// certifcate, and the contents match the previously checked quote.
    /// After that check has been performed, the enclave will use the
    /// verification report for all requests until another verfication report
    /// has been successfully loaded in it's place.
    fn verify_ias_report(&self, ias_report: VerificationReport) -> Result<()>;

    /// Retrieve a copy of the cached verification report.
    fn get_ias_report(&self) -> Result<VerificationReport>;
}
