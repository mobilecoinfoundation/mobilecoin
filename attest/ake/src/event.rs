// Copyright (c) 2018-2021 The MobileCoin Foundation

//!  data structures not defined elsewhere.

use crate::mealy::{Input as MealyInput, Output as MealyOutput};
use aead::{AeadMut, NewAead};
use alloc::vec::Vec;
use core::marker::PhantomData;
use digest::{BlockInput, FixedOutput, Reset, Update};
use mc_attest_core::{VerificationReport, Verifier};
use mc_crypto_keys::Kex;
use mc_crypto_noise::{HandshakeIX, HandshakeNX, HandshakePattern, NoiseCipher, ProtocolName};

/// An input used to inject the relevant local data needed to transform Start
/// into an AuthPending for node-to-node authentication.
pub struct NodeInitiate<KexAlgo, Cipher, DigestType>
where
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
    /// This is the local node's identity key
    pub(crate) local_identity: KexAlgo::Private,
    /// This is the local node's ias report.
    pub(crate) ias_report: VerificationReport,

    _kex: PhantomData<fn() -> KexAlgo>,
    _cipher: PhantomData<fn() -> Cipher>,
    _digest: PhantomData<fn() -> DigestType>,
}

impl<KexAlgo, Cipher, DigestType> NodeInitiate<KexAlgo, Cipher, DigestType>
where
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
    /// Create a new input event to initiate a node-to-node channel.
    pub fn new(local_identity: KexAlgo::Private, ias_report: VerificationReport) -> Self {
        Self {
            local_identity,
            ias_report,
            _kex: PhantomData::default(),
            _cipher: PhantomData::default(),
            _digest: PhantomData::default(),
        }
    }
}

impl<KexAlgo, Cipher, DigestType> MealyInput for NodeInitiate<KexAlgo, Cipher, DigestType>
where
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
}

/// An input used to transform a Start into an AuthPending for client-to-node
/// authentication.
pub struct ClientInitiate<KexAlgo, Cipher, DigestType>
where
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
    _kex: PhantomData<fn() -> KexAlgo>,
    _cipher: PhantomData<fn() -> Cipher>,
    _digest: PhantomData<fn() -> DigestType>,
}

impl<KexAlgo, Cipher, DigestType> Default for ClientInitiate<KexAlgo, Cipher, DigestType>
where
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
    fn default() -> Self {
        Self {
            _kex: PhantomData::default(),
            _cipher: PhantomData::default(),
            _digest: PhantomData::default(),
        }
    }
}

impl<KexAlgo, Cipher, DigestType> MealyInput for ClientInitiate<KexAlgo, Cipher, DigestType>
where
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
}

/// An opaque blob of noise protocol handshake bytes, generated by an initiator,
/// and consumed by a responder.
pub struct AuthRequestOutput<Handshake, KexAlgo, Cipher, DigestType>
where
    Handshake: HandshakePattern,
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
    /// The actual AuthRequest data
    pub(crate) data: Vec<u8>,

    /// Type consumption
    _protocol_name: ProtocolName<Handshake, KexAlgo, Cipher, DigestType>,
}

impl<Handshake, KexAlgo, Cipher, DigestType> From<Vec<u8>>
    for AuthRequestOutput<Handshake, KexAlgo, Cipher, DigestType>
where
    Handshake: HandshakePattern,
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
    fn from(data: Vec<u8>) -> Self {
        Self {
            data,
            _protocol_name: ProtocolName::<Handshake, KexAlgo, Cipher, DigestType>::default(),
        }
    }
}

impl<Handshake, KexAlgo, Cipher, DigestType>
    From<AuthRequestOutput<Handshake, KexAlgo, Cipher, DigestType>> for Vec<u8>
where
    Handshake: HandshakePattern,
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
    fn from(src: AuthRequestOutput<Handshake, KexAlgo, Cipher, DigestType>) -> Vec<u8> {
        src.data
    }
}

impl<Handshake, KexAlgo, Cipher, DigestType> AsRef<[u8]>
    for AuthRequestOutput<Handshake, KexAlgo, Cipher, DigestType>
where
    Handshake: HandshakePattern,
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
    fn as_ref(&self) -> &[u8] {
        self.data.as_ref()
    }
}

/// An authentication request is output from an initiator
impl<Handshake, KexAlgo, Cipher, DigestType> MealyOutput
    for AuthRequestOutput<Handshake, KexAlgo, Cipher, DigestType>
where
    Handshake: HandshakePattern,
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
}

/// An input used to transform a Start into a Ready for a client-to-node
/// responder.
///
/// It contains the AuthRequestOutput generated by an initiator, and the
/// supporting data a responder will need to complete the NX handshake.
pub struct ClientAuthRequestInput<KexAlgo, Cipher, DigestType>
where
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
    /// This is the local node's identity key
    pub(crate) local_identity: KexAlgo::Private,
    /// This is the local node's ias report.
    pub(crate) ias_report: VerificationReport,

    /// The auth request input, including payload, if any
    pub(crate) data: AuthRequestOutput<HandshakeNX, KexAlgo, Cipher, DigestType>,
}

impl<KexAlgo, Cipher, DigestType> MealyInput for ClientAuthRequestInput<KexAlgo, Cipher, DigestType>
where
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
}

impl<KexAlgo, Cipher, DigestType> ClientAuthRequestInput<KexAlgo, Cipher, DigestType>
where
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
    pub fn new(
        data: AuthRequestOutput<HandshakeNX, KexAlgo, Cipher, DigestType>,
        local_identity: KexAlgo::Private,
        ias_report: VerificationReport,
    ) -> Self {
        Self {
            local_identity,
            ias_report,
            data,
        }
    }
}

/// An input used to transform a Start into a Ready for a node-to-node
/// responder.
///
/// It contains the AuthRequestOutput generated by an initiator, and the
/// supporting data a responder will need to complete the handshake.
pub struct NodeAuthRequestInput<KexAlgo, Cipher, DigestType>
where
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
    /// This is the local node's identity key
    pub(crate) local_identity: KexAlgo::Private,
    /// This is the local node's ias report.
    pub(crate) ias_report: VerificationReport,
    /// This is the verifier used to examine the initiator's IAS report
    pub(crate) verifier: Verifier,

    /// The auth request input, including payload, if any
    pub(crate) data: AuthRequestOutput<HandshakeIX, KexAlgo, Cipher, DigestType>,
}

impl<KexAlgo, Cipher, DigestType> MealyInput for NodeAuthRequestInput<KexAlgo, Cipher, DigestType>
where
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
}

impl<KexAlgo, Cipher, DigestType> NodeAuthRequestInput<KexAlgo, Cipher, DigestType>
where
    KexAlgo: Kex,
    Cipher: AeadMut + NewAead + NoiseCipher + Sized,
    DigestType: BlockInput + Clone + Default + FixedOutput + Update + Reset,
{
    pub fn new(
        data: AuthRequestOutput<HandshakeIX, KexAlgo, Cipher, DigestType>,
        local_identity: KexAlgo::Private,
        ias_report: VerificationReport,
        verifier: Verifier,
    ) -> Self {
        Self {
            local_identity,
            ias_report,
            verifier,
            data,
        }
    }
}

/// An opaque blob containing output by a responder to complete a noise
/// handshake.
pub struct AuthResponseOutput(Vec<u8>);

impl From<Vec<u8>> for AuthResponseOutput {
    fn from(src: Vec<u8>) -> Self {
        Self(src)
    }
}

impl AsRef<[u8]> for AuthResponseOutput {
    fn as_ref(&self) -> &[u8] {
        self.0.as_ref()
    }
}

impl From<AuthResponseOutput> for Vec<u8> {
    fn from(src: AuthResponseOutput) -> Vec<u8> {
        src.0
    }
}

/// An authentication response is output from a responder
impl MealyOutput for AuthResponseOutput {}

/// The authentication response is combined with a verifier for the initiator.
pub struct AuthResponseInput {
    pub(crate) data: Vec<u8>,
    pub(crate) verifier: Verifier,
}

impl AuthResponseInput {
    pub fn new(data: AuthResponseOutput, verifier: Verifier) -> Self {
        Self {
            data: data.0,
            verifier,
        }
    }
}

impl AsRef<[u8]> for AuthResponseInput {
    fn as_ref(&self) -> &[u8] {
        self.data.as_ref()
    }
}

impl From<AuthResponseInput> for Vec<u8> {
    fn from(src: AuthResponseInput) -> Vec<u8> {
        src.data
    }
}

/// An authentication response input to a responder
impl MealyInput for AuthResponseInput {}

/// The IAS report is the final output when authentication succeeds.
impl MealyOutput for VerificationReport {}

/// A type similar to aead::Payload used to distinguish writer inputs from
/// outputs.
pub struct Plaintext<'aad, 'msg> {
    pub aad: &'aad [u8],
    pub msg: &'msg [u8],
}

impl<'aad, 'msg> Plaintext<'aad, 'msg> {
    pub fn new(aad: &'aad [u8], msg: &'msg [u8]) -> Self {
        Self { aad, msg }
    }
}

/// Plaintext may be provided to an FST for encryption into a vector
impl MealyInput for Plaintext<'_, '_> {}

/// A type similar to aead::Payload used to distinguish reader inputs from
/// outputs.
pub struct Ciphertext<'aad, 'msg> {
    pub aad: &'aad [u8],
    pub msg: &'msg [u8],
}

impl<'aad, 'msg> Ciphertext<'aad, 'msg> {
    pub fn new(aad: &'aad [u8], msg: &'msg [u8]) -> Self {
        Self { aad, msg }
    }
}

/// A ciphertext may be provided to a FST for decryption into a vector
impl MealyInput for Ciphertext<'_, '_> {}

/// Our outputs may be simple vectors for the proto-inside-grpc use case.
impl MealyOutput for Vec<u8> {}
