# Copyright (c) 2018-2022 The MobileCoin Foundation
fullnameOverride: ''

imagePullSecrets:
- name: docker-credentials

image:
  org: mobilecoin
  tag: ''

### Shared values with child charts.
global:
  # Shared across all instances of consensusNodeConfig config.
  node:
    ledgerDistribution:
      awsAccessKeyId: ''
      awsSecretAccessKey: ''
      awsRegion: ''
      s3Bucket: ''
      startFrom: last

    networkConfig:
      threshold: ''
      peers: {}

    # tokensConfig:
    #   tokensSignedJson: |-
    #     { json }

### Enable to launch child chart to create node required configMaps and secrets.
#   See helm/consensus-node-config/values.yaml for config details.
consensusNodeConfig:
  enabled: false
  fullnameOverride: '{{ .Release.Name }}'
  node:
    client:
      hostname: ''
    peer:
      hostname: ''

### Enable to launch child chart to create core common configMaps and secrets.
#   See helm/mc-core-common-config/values.yaml for config details.
mcCoreCommonConfig:
  enabled: false
  # clientAuth:
  #   token: ''
  # ias:
  #   key: ''
  #   spid: ''
  # mobileCoinNetwork:
  #   network: ''
  #   partner: ''
  # sentry:
  #   consensus-sentry-dsn: ''
  #   ledger-distribution-sentry-dsn: ''
  #   fog-report-sentry-dsn: ''
  #   fog-view-sentry-dsn: ''
  #   fog-ledger-sentry-dsn: ''
  #   fog-ingest-sentry-dsn: ''

# Consensus node settings
node:
  image:
    org: ''
    name: node_hw

  podAnnotations:
    fluentbit.io/include: 'true'
    fluentbit.io/exclude-jaeger-agent: 'true'

  nodeSelector:
    sgx-enabled-node: 'true'

  resources:
    limits:
      intel.com/sgx: 5000
    requests:
      intel.com/sgx: 5000

  tolerations:
  - key: sgx
    operator: Equal
    value: 'true'
    effect: NoSchedule

  initContainers:
  - name: copy-ledger-from-container
    image: '{{ .Values.node.image.org | default .Values.image.org }}/{{ .Values.node.image.name }}:{{ .Values.image.tag | default .Chart.AppVersion }}'
    imagePullPolicy: Always
    env:
    - name: INITIAL_KEYS_SEED
      valueFrom:
        secretKeyRef:
          name: sample-keys-seeds
          key: INITIAL_KEYS_SEED
          optional: true
    command: [ '/bin/bash' ]
    # CBB 1.2+ - convert to using MNEMONIC keys
    args:
    - -c
    - |
      set -e
      if [ ! -f /ledger/data.mdb ]; then
        if [[ -n "${INITIAL_KEYS_SEED}" ]]; then
          echo "INITIAL_KEYS_SEED found - populating origin data"
          export INITIALIZE_LEDGER="true"
          /usr/local/bin/generate_origin_data.sh
          cp /tmp/sample_data/ledger/data.mdb /ledger
        elif [ -f /var/lib/mobilecoin/origin_data/data.mdb ]; then
          echo "Copying ledger /var/lib/mobilecoin/origin_data/data.mdb to /ledger"
          cp /var/lib/mobilecoin/origin_data/data.mdb /ledger
        else
          echo "INITIAL_KEYS_SEED not set and cannot find origin ledger file"
          exit 1
        fi
      else
        echo "Ledger /ledger/data.mdb already exists"
      fi
    volumeMounts:
    - name: ledger-db-dir
      mountPath: /ledger
  - name: migrate-ledger
    image: '{{ .Values.node.image.org | default .Values.image.org }}/{{ .Values.node.image.name }}:{{ .Values.image.tag | default .Chart.AppVersion }}'
    imagePullPolicy: Always
    command: [ '/bin/bash' ]
    args:
    - -c
    - |
      set -e
      if [[ -f "/ledger/data.mdb" ]]
      then
        cp /ledger/data.mdb /ledger/data.mdb.bak
        /usr/bin/mc-ledger-migration --ledger-db /ledger
      fi
    volumeMounts:
    - name: ledger-db-dir
      mountPath: /ledger

  persistence:
    enabled: true
    spec:
      storageClassName: fast
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 512Gi

  client:
    ingress:
      annotations:
        cert-manager.io/cluster-issuer: letsencrypt-production-http
        # HAProxy Ingress
        haproxy.org/server-proto: 'h2'              # Force GRPC/H2 mode
        haproxy.org/server-ssl: 'false'             # The backend (server) is http
        haproxy.org/timeout-client: 239s            # 4 min timeout on azure
        haproxy.org/timeout-server: 239s
        haproxy.org/timeout-http-keep-alive: 120s
        haproxy.org/abortonclose: 'true'
        haproxy.org/backend-config-snippet: |-
          http-reuse aggressive
        # Nginx Ingress
        nginx.ingress.kubernetes.io/ssl-redirect: 'true'
        nginx.ingress.kubernetes.io/backend-protocol: 'GRPC'

  peer:
    ingress:
      annotations:
        cert-manager.io/cluster-issuer: letsencrypt-production-http
        # HAProxy Ingress
        haproxy.org/server-proto: 'h2'              # Force GRPC/H2 mode
        haproxy.org/server-ssl: 'false'             # The backend (server) is http
        haproxy.org/timeout-client: 239s            # 4 min timeout on azure
        haproxy.org/timeout-server: 239s
        haproxy.org/timeout-http-keep-alive: 120s
        haproxy.org/abortonclose: 'true'
        haproxy.org/backend-config-snippet: |-
          http-reuse aggressive
        # Nginx Ingress
        nginx.ingress.kubernetes.io/ssl-redirect: 'true'
        nginx.ingress.kubernetes.io/backend-protocol: 'GRPC'

# GRPC Gateway settings
grpcGateway:
  image:
    org: ''
    name: go-grpc-gateway
  nodeSelector: {}
  ingress:
    cert-manager.io/cluster-issuer: letsencrypt-production-http
    #HAProxy Ingress
    haproxy.org/path-rewrite: /gw/(.*) /\1      # Strip the /gw prefix
    haproxy.org/server-ssl: 'false'             # The backend (server) is http
    haproxy.org/timeout-client: 239s            # 4 min timeout on azure
    haproxy.org/timeout-server: 239s
    haproxy.org/timeout-http-keep-alive: 120s
    haproxy.org/abortonclose: 'true'
    haproxy.org/backend-config-snippet: |-
      http-reuse aggressive
    # Nginx ingress
    nginx.ingress.kubernetes.io/ssl-redirect: 'true'

# Disable Client Connects
acceptClientConnections: true

jaegerTracing:
  enabled: true
  collector: 'dns:///jaeger-collector:14250'
